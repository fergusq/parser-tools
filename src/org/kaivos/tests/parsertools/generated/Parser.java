// AUTO GENERATED PARSER CLASS
// GENERATED BY ParserGenerator1
//
// GENERATOR VERSION: a0.1
// (C) 2013 Iikka Hauhio - ALL RIGHTS RESERVED
// THIS GENERATOR IS ONLY A PROTOTYPE
//
// GRAMMAR FILE: tests/real.language

package org.kaivos.tests.parsertools.generated;
import org.kaivos.parsertools.ParserTree;
import org.kaivos.sc.ITokenList;
import org.kaivos.stg.error.SyntaxError;
import org.kaivos.stg.error.UnexpectedTokenSyntaxError;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import org.kaivos.sc.TokenScanner;
import java.io.IOException;

interface ParserTreeRule {
	public boolean parse(ITokenList l) throws SyntaxError;
}

class PTreeNode {
	Map<String, Object> children = new HashMap<>();
}

public class Parser extends ParserTree implements ParserTreeRule {

	class GeneratedRule_Member extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (s2.equals(".")) {
				if (seek(s).equals(".")) children.put("op", next(s));
				else accept(".", s);
				children.put("member", next(s));
				return true;
			}
			if (s2.equals("[")) {
				if (seek(s).equals("[")) children.put("op", next(s));
				else accept("[", s);
				{
					ParserTreeRule rule = new GeneratedRule_Expression();
					if(!rule.parse(s)) ; else children.put("key", rule);
				}
				accept("]", s);
				return true;
			}
			accept(new String[] {".", "["}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_Member ast_Member(PTreeNode node) {
		if (node == null) return null;
		Rule_Member a = new Rule_Member();
		a.key = ast_Expression((PTreeNode) node.children.get("key"));
		if (node.children.get("op") != null)
		a.op = ((String) node.children.get("op"));
		if (node.children.get("member") != null)
		a.member = ((String) node.children.get("member"));
		return a;
	}

	class GeneratedRule_Arguments extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (s2.equals("(")) {
				accept("(", s);
				if (Parser.isValidIdentifier(seek(s)) || seek(s).equals("(") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("-") || seek(s).equals("nil")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (Parser.isValidIdentifier(s2) || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
							{
								ParserTreeRule rule = new GeneratedRule_Expression();
								if(!rule.parse(s)) ; else if (children.get("args") == null) {
									children.put("args", new ArrayList<Object>());
									((List<Object>) children.get("args")).add(rule);
								}
								else ((List<Object>) children.get("args")).add(rule);
							}
							if (seek(s).equals(",")) {
								int si2 = s.index();
								while (new ParserTreeRule() {
									@Override
									public boolean parse(ITokenList s) throws SyntaxError {
									if (seek(s).equals(",")) {
										String s2 = seek(s);
										if (s2.equals(",")) {
											accept(",", s);
											{
												ParserTreeRule rule = new GeneratedRule_Expression();
												if(!rule.parse(s)) ; else if (children.get("args") == null) {
													children.put("args", new ArrayList<Object>());
													((List<Object>) children.get("args")).add(rule);
												}
												else ((List<Object>) children.get("args")).add(rule);
											}
											return true;
										}
										accept(new String[] {","}, s);
										return false;
									} return false;
									}
								}.parse(s)) si2 = s.index();
								s.setIndex(si2);
							}
							return true;
						}
						accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "func", "nil", "{"}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				accept(")", s);
				return true;
			}
			accept(new String[] {"("}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_Arguments ast_Arguments(PTreeNode node) {
		if (node == null) return null;
		Rule_Arguments a = new Rule_Arguments();
		a.args = new ArrayList<>();
		if (node.children.get("args") != null)
		for (Object o: (List<?>) node.children.get("args")) {
			a.args.add(ast_Expression((PTreeNode) o));
		}
		return a;
	}

	class GeneratedRule_MemberAccess extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (Parser.isValidIdentifier(s2) || s2.equals("(") || s2.equals("func") || s2.equals("{") || s2.matches("[0-9]+") || s2.equals("-") || s2.equals("nil")) {
				{
					ParserTreeRule rule = new GeneratedRule_FunctionCall();
					if(!rule.parse(s)) ; else children.put("a", rule);
				}
				if (seek(s).equals(":") || seek(s).equals(".") || seek(s).equals("[") || seek(s).equals("=")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (s2.equals(":") || s2.equals(".") || s2.equals("=") || s2.equals("[")) {
							if (seek(s).equals(".") || seek(s).equals("[")) {
								int si2 = s.index();
								while (new ParserTreeRule() {
									@Override
									public boolean parse(ITokenList s) throws SyntaxError {
									if (seek(s).equals(".") || seek(s).equals("[")) {
										String s2 = seek(s);
										if (s2.equals(".") || s2.equals("[")) {
											{
												ParserTreeRule rule = new GeneratedRule_Member();
												if(!rule.parse(s)) ; else if (children.get("b") == null) {
													children.put("b", new ArrayList<Object>());
													((List<Object>) children.get("b")).add(rule);
												}
												else ((List<Object>) children.get("b")).add(rule);
											}
											return true;
										}
										accept(new String[] {".", "["}, s);
										return false;
									} return false;
									}
								}.parse(s)) si2 = s.index();
								s.setIndex(si2);
							}
							if (seek(s).equals(":") || seek(s).equals("=")) {
								int si2 = s.index();
								if (!new ParserTreeRule() {
									@Override
									public boolean parse(ITokenList s) throws SyntaxError {
									String s2 = seek(s);
									if (s2.equals("=")) {
										if (seek(s).equals("=")) children.put("op", next(s));
										else accept("=", s);
										{
											ParserTreeRule rule = new GeneratedRule_Expression();
											if(!rule.parse(s)) ; else children.put("value", rule);
										}
										return true;
									}
									if (s2.equals(":")) {
										if (seek(s).equals(":")) children.put("op", next(s));
										else accept(":", s);
										{
											ParserTreeRule rule = new GeneratedRule_Expression();
											if(!rule.parse(s)) ; else children.put("value", rule);
										}
										return true;
									}
									accept(new String[] {":", "="}, s);
									return false;
									}
								}.parse(s)) s.setIndex(si2);
							}
							return true;
						}
						accept(new String[] {".", ":", "=", "["}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				return true;
			}
			accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "func", "nil", "{"}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_MemberAccess ast_MemberAccess(PTreeNode node) {
		if (node == null) return null;
		Rule_MemberAccess a = new Rule_MemberAccess();
		a.a = ast_FunctionCall((PTreeNode) node.children.get("a"));
		if (node.children.get("op") != null)
		a.op = ((String) node.children.get("op"));
		a.b = new ArrayList<>();
		if (node.children.get("b") != null)
		for (Object o: (List<?>) node.children.get("b")) {
			a.b.add(ast_Member((PTreeNode) o));
		}
		a.value = ast_Expression((PTreeNode) node.children.get("value"));
		return a;
	}

	class GeneratedRule_Start extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (s2.equals("break") || Parser.isValidIdentifier(s2) || s2.equals("if") || s2.equals("return") || s2.equals("do") || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("print") || s2.equals("while") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
				{
					ParserTreeRule rule = new GeneratedRule_Statement();
					if(!rule.parse(s)) ; else if (children.get("stm") == null) {
						children.put("stm", new ArrayList<Object>());
						((List<Object>) children.get("stm")).add(rule);
					}
					else ((List<Object>) children.get("stm")).add(rule);
				}
				if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
					int si2 = s.index();
					while (new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
							String s2 = seek(s);
							if (s2.equals("break") || Parser.isValidIdentifier(s2) || s2.equals("if") || s2.equals("return") || s2.equals("do") || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("print") || s2.equals("while") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
								{
									ParserTreeRule rule = new GeneratedRule_Statement();
									if(!rule.parse(s)) ; else if (children.get("stm") == null) {
										children.put("stm", new ArrayList<Object>());
										((List<Object>) children.get("stm")).add(rule);
									}
									else ((List<Object>) children.get("stm")).add(rule);
								}
								return true;
							}
							accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "break", "do", "func", "if", "nil", "print", "return", "while", "{"}, s);
							return false;
						} return false;
						}
					}.parse(s)) si2 = s.index();
					s.setIndex(si2);
				}
				run(ast_Start(GeneratedRule_Start.this));
				return true;
			}
			accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "break", "do", "func", "if", "nil", "print", "return", "while", "{"}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_Start ast_Start(PTreeNode node) {
		if (node == null) return null;
		Rule_Start a = new Rule_Start();
		a.stm = new ArrayList<>();
		if (node.children.get("stm") != null)
		for (Object o: (List<?>) node.children.get("stm")) {
			a.stm.add(ast_Statement((PTreeNode) o));
		}
		return a;
	}

	class GeneratedRule_LValue extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (Parser.isValidIdentifier(s2)) {
				children.put("variable", next(s));
				return true;
			}
			accept(new String[] {"<ID>"}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_LValue ast_LValue(PTreeNode node) {
		if (node == null) return null;
		Rule_LValue a = new Rule_LValue();
		if (node.children.get("variable") != null)
		a.variable = ((String) node.children.get("variable"));
		return a;
	}

	class GeneratedRule_Prim extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (s2.matches("[0-9]+")) {
				children.put("number", next(s));
				return true;
			}
			if (s2.equals("(") || s2.equals("-")) {
				if (seek(s).equals("-")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (s2.equals("-")) {
							if (seek(s).equals("-")) children.put("op", next(s));
							else accept("-", s);
							return true;
						}
						accept(new String[] {"-"}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				accept("(", s);
				{
					ParserTreeRule rule = new GeneratedRule_Expression();
					if(!rule.parse(s)) ; else children.put("expr", rule);
				}
				accept(")", s);
				return true;
			}
			if (s2.equals("nil")) {
				if (seek(s).equals("nil")) children.put("op", next(s));
				else accept("nil", s);
				if (seek(s).equals("(")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (s2.equals("(")) {
							accept("(", s);
							{
								ParserTreeRule rule = new GeneratedRule_Expression();
								if(!rule.parse(s)) ; else children.put("expr", rule);
							}
							accept(")", s);
							return true;
						}
						accept(new String[] {"("}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				return true;
			}
			if (s2.equals("{")) {
				if (seek(s).equals("{")) children.put("op", next(s));
				else accept("{", s);
				if (Parser.isValidIdentifier(seek(s)) || seek(s).equals("(") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("-") || seek(s).equals("nil")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (Parser.isValidIdentifier(s2) || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
							{
								ParserTreeRule rule = new GeneratedRule_Expression();
								if(!rule.parse(s)) ; else if (children.get("values") == null) {
									children.put("values", new ArrayList<Object>());
									((List<Object>) children.get("values")).add(rule);
								}
								else ((List<Object>) children.get("values")).add(rule);
							}
							if (seek(s).equals(",")) {
								int si2 = s.index();
								while (new ParserTreeRule() {
									@Override
									public boolean parse(ITokenList s) throws SyntaxError {
									if (seek(s).equals(",")) {
										String s2 = seek(s);
										if (s2.equals(",")) {
											accept(",", s);
											{
												ParserTreeRule rule = new GeneratedRule_Expression();
												if(!rule.parse(s)) ; else if (children.get("values") == null) {
													children.put("values", new ArrayList<Object>());
													((List<Object>) children.get("values")).add(rule);
												}
												else ((List<Object>) children.get("values")).add(rule);
											}
											return true;
										}
										accept(new String[] {","}, s);
										return false;
									} return false;
									}
								}.parse(s)) si2 = s.index();
								s.setIndex(si2);
							}
							return true;
						}
						accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "func", "nil", "{"}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				accept("}", s);
				return true;
			}
			if (s2.equals("func")) {
				if (seek(s).equals("func")) children.put("op", next(s));
				else accept("func", s);
				accept("(", s);
				if (Parser.isValidIdentifier(seek(s))) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (Parser.isValidIdentifier(s2)) {
							if (children.get("params") == null) {
								children.put("params", new ArrayList<Object>());
								((List<Object>) children.get("params")).add(next(s));
							}
							else ((List<Object>) children.get("params")).add(next(s));
							if (seek(s).equals(",")) {
								int si2 = s.index();
								while (new ParserTreeRule() {
									@Override
									public boolean parse(ITokenList s) throws SyntaxError {
									if (seek(s).equals(",")) {
										String s2 = seek(s);
										if (s2.equals(",")) {
											accept(",", s);
											if (children.get("params") == null) {
												children.put("params", new ArrayList<Object>());
												((List<Object>) children.get("params")).add(next(s));
											}
											else ((List<Object>) children.get("params")).add(next(s));
											return true;
										}
										accept(new String[] {","}, s);
										return false;
									} return false;
									}
								}.parse(s)) si2 = s.index();
								s.setIndex(si2);
							}
							return true;
						}
						accept(new String[] {"<ID>"}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				accept(")", s);
				accept("->", s);
				{
					ParserTreeRule rule = new GeneratedRule_Statement();
					if(!rule.parse(s)) ; else children.put("stm", rule);
				}
				return true;
			}
			if (Parser.isValidIdentifier(s2)) {
				{
					ParserTreeRule rule = new GeneratedRule_LValue();
					if(!rule.parse(s)) ; else children.put("lval", rule);
				}
				if (seek(s).equals("=")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (s2.equals("=")) {
							accept("=", s);
							{
								ParserTreeRule rule = new GeneratedRule_Expression();
								if(!rule.parse(s)) ; else children.put("expr", rule);
							}
							return true;
						}
						accept(new String[] {"="}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				return true;
			}
			accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "func", "nil", "{"}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_Prim ast_Prim(PTreeNode node) {
		if (node == null) return null;
		Rule_Prim a = new Rule_Prim();
		a.expr = ast_Expression((PTreeNode) node.children.get("expr"));
		if (node.children.get("op") != null)
		a.op = ((String) node.children.get("op"));
		a.lval = ast_LValue((PTreeNode) node.children.get("lval"));
		if (node.children.get("params") != null)
		a.params = ((List<String>) node.children.get("params"));
		a.stm = ast_Statement((PTreeNode) node.children.get("stm"));
		if (node.children.get("number") != null)
		a.number = Integer.parseInt((String) node.children.get("number"));
		a.values = new ArrayList<>();
		if (node.children.get("values") != null)
		for (Object o: (List<?>) node.children.get("values")) {
			a.values.add(ast_Expression((PTreeNode) o));
		}
		return a;
	}

	class GeneratedRule_Statement extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (Parser.isValidIdentifier(s2) || s2.equals("(") || s2.equals("func") || s2.equals("{") || s2.equals("print") || s2.matches("[0-9]+") || s2.equals("-") || s2.equals("nil")) {
				if (seek(s).equals("print")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (s2.equals("print")) {
							if (seek(s).equals("print")) children.put("cmd", next(s));
							else accept("print", s);
							return true;
						}
						accept(new String[] {"print"}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				{
					ParserTreeRule rule = new GeneratedRule_Expression();
					if(!rule.parse(s)) ; else children.put("expr", rule);
				}
				if (seek(s).equals(";")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (s2.equals(";")) {
							accept(";", s);
							return true;
						}
						accept(new String[] {";"}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				return true;
			}
			if (s2.equals("do")) {
				if (seek(s).equals("do")) children.put("cmd", next(s));
				else accept("do", s);
				if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
					int si2 = s.index();
					while (new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
							String s2 = seek(s);
							if (s2.equals("break") || Parser.isValidIdentifier(s2) || s2.equals("if") || s2.equals("return") || s2.equals("do") || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("print") || s2.equals("while") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
								{
									ParserTreeRule rule = new GeneratedRule_Statement();
									if(!rule.parse(s)) ; else if (children.get("block") == null) {
										children.put("block", new ArrayList<Object>());
										((List<Object>) children.get("block")).add(rule);
									}
									else ((List<Object>) children.get("block")).add(rule);
								}
								return true;
							}
							accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "break", "do", "func", "if", "nil", "print", "return", "while", "{"}, s);
							return false;
						} return false;
						}
					}.parse(s)) si2 = s.index();
					s.setIndex(si2);
				}
				accept("end", s);
				return true;
			}
			if (s2.equals("if")) {
				if (seek(s).equals("if")) children.put("cmd", next(s));
				else accept("if", s);
				{
					ParserTreeRule rule = new GeneratedRule_Expression();
					if(!rule.parse(s)) ; else children.put("cond", rule);
				}
				accept("then", s);
				if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
					int si2 = s.index();
					while (new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
							String s2 = seek(s);
							if (s2.equals("break") || Parser.isValidIdentifier(s2) || s2.equals("if") || s2.equals("return") || s2.equals("do") || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("print") || s2.equals("while") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
								{
									ParserTreeRule rule = new GeneratedRule_Statement();
									if(!rule.parse(s)) ; else if (children.get("block") == null) {
										children.put("block", new ArrayList<Object>());
										((List<Object>) children.get("block")).add(rule);
									}
									else ((List<Object>) children.get("block")).add(rule);
								}
								return true;
							}
							accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "break", "do", "func", "if", "nil", "print", "return", "while", "{"}, s);
							return false;
						} return false;
						}
					}.parse(s)) si2 = s.index();
					s.setIndex(si2);
				}
				if (seek(s).equals("elseif")) {
					int si2 = s.index();
					while (new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						if (seek(s).equals("elseif")) {
							String s2 = seek(s);
							if (s2.equals("elseif")) {
								accept("elseif", s);
								{
									ParserTreeRule rule = new GeneratedRule_Expression();
									if(!rule.parse(s)) ; else if (children.get("elsecond") == null) {
										children.put("elsecond", new ArrayList<Object>());
										((List<Object>) children.get("elsecond")).add(rule);
									}
									else ((List<Object>) children.get("elsecond")).add(rule);
								}
								{
									ParserTreeRule rule = new GeneratedRule_StmList();
									if(!rule.parse(s)) ; else if (children.get("elseif") == null) {
										children.put("elseif", new ArrayList<Object>());
										((List<Object>) children.get("elseif")).add(rule);
									}
									else ((List<Object>) children.get("elseif")).add(rule);
								}
								return true;
							}
							accept(new String[] {"elseif"}, s);
							return false;
						} return false;
						}
					}.parse(s)) si2 = s.index();
					s.setIndex(si2);
				}
				if (seek(s).equals("else")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (s2.equals("else")) {
							accept("else", s);
							if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
								int si2 = s.index();
								while (new ParserTreeRule() {
									@Override
									public boolean parse(ITokenList s) throws SyntaxError {
									if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
										String s2 = seek(s);
										if (s2.equals("break") || Parser.isValidIdentifier(s2) || s2.equals("if") || s2.equals("return") || s2.equals("do") || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("print") || s2.equals("while") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
											{
												ParserTreeRule rule = new GeneratedRule_Statement();
												if(!rule.parse(s)) ; else if (children.get("elseBlock") == null) {
													children.put("elseBlock", new ArrayList<Object>());
													((List<Object>) children.get("elseBlock")).add(rule);
												}
												else ((List<Object>) children.get("elseBlock")).add(rule);
											}
											return true;
										}
										accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "break", "do", "func", "if", "nil", "print", "return", "while", "{"}, s);
										return false;
									} return false;
									}
								}.parse(s)) si2 = s.index();
								s.setIndex(si2);
							}
							return true;
						}
						accept(new String[] {"else"}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				accept("end", s);
				return true;
			}
			if (s2.equals("while")) {
				if (seek(s).equals("while")) children.put("cmd", next(s));
				else accept("while", s);
				{
					ParserTreeRule rule = new GeneratedRule_Expression();
					if(!rule.parse(s)) ; else children.put("cond", rule);
				}
				accept("do", s);
				if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
					int si2 = s.index();
					while (new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
							String s2 = seek(s);
							if (s2.equals("break") || Parser.isValidIdentifier(s2) || s2.equals("if") || s2.equals("return") || s2.equals("do") || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("print") || s2.equals("while") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
								{
									ParserTreeRule rule = new GeneratedRule_Statement();
									if(!rule.parse(s)) ; else if (children.get("block") == null) {
										children.put("block", new ArrayList<Object>());
										((List<Object>) children.get("block")).add(rule);
									}
									else ((List<Object>) children.get("block")).add(rule);
								}
								return true;
							}
							accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "break", "do", "func", "if", "nil", "print", "return", "while", "{"}, s);
							return false;
						} return false;
						}
					}.parse(s)) si2 = s.index();
					s.setIndex(si2);
				}
				accept("end", s);
				return true;
			}
			if (s2.equals("break")) {
				if (seek(s).equals("break")) children.put("cmd", next(s));
				else accept("break", s);
				if (seek(s).equals(";")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (s2.equals(";")) {
							accept(";", s);
							return true;
						}
						accept(new String[] {";"}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				return true;
			}
			if (s2.equals("return")) {
				if (seek(s).equals("return")) children.put("cmd", next(s));
				else accept("return", s);
				if (Parser.isValidIdentifier(seek(s)) || seek(s).equals("(") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("-") || seek(s).equals("nil")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (Parser.isValidIdentifier(s2) || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
							{
								ParserTreeRule rule = new GeneratedRule_Expression();
								if(!rule.parse(s)) ; else children.put("rv", rule);
							}
							return true;
						}
						accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "func", "nil", "{"}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				if (seek(s).equals(";")) {
					int si2 = s.index();
					if (!new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						String s2 = seek(s);
						if (s2.equals(";")) {
							accept(";", s);
							return true;
						}
						accept(new String[] {";"}, s);
						return false;
						}
					}.parse(s)) s.setIndex(si2);
				}
				return true;
			}
			accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "break", "do", "func", "if", "nil", "print", "return", "while", "{"}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_Statement ast_Statement(PTreeNode node) {
		if (node == null) return null;
		Rule_Statement a = new Rule_Statement();
		a.elseif = new ArrayList<>();
		if (node.children.get("elseif") != null)
		for (Object o: (List<?>) node.children.get("elseif")) {
			a.elseif.add(ast_StmList((PTreeNode) o));
		}
		a.expr = ast_Expression((PTreeNode) node.children.get("expr"));
		a.elseBlock = new ArrayList<>();
		if (node.children.get("elseBlock") != null)
		for (Object o: (List<?>) node.children.get("elseBlock")) {
			a.elseBlock.add(ast_Statement((PTreeNode) o));
		}
		if (node.children.get("cmd") != null)
		a.cmd = ((String) node.children.get("cmd"));
		a.block = new ArrayList<>();
		if (node.children.get("block") != null)
		for (Object o: (List<?>) node.children.get("block")) {
			a.block.add(ast_Statement((PTreeNode) o));
		}
		a.cond = ast_Expression((PTreeNode) node.children.get("cond"));
		a.rv = ast_Expression((PTreeNode) node.children.get("rv"));
		a.elsecond = new ArrayList<>();
		if (node.children.get("elsecond") != null)
		for (Object o: (List<?>) node.children.get("elsecond")) {
			a.elsecond.add(ast_Expression((PTreeNode) o));
		}
		return a;
	}

	class GeneratedRule_Expression extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (Parser.isValidIdentifier(s2) || s2.equals("(") || s2.equals("func") || s2.equals("{") || s2.matches("[0-9]+") || s2.equals("-") || s2.equals("nil")) {
				{
					ParserTreeRule rule = new GeneratedRule_Term();
					if(!rule.parse(s)) ; else children.put("a", rule);
				}
				if (seek(s).equals("+") || seek(s).equals("-")) {
					int si2 = s.index();
					while (new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						if (seek(s).equals("+") || seek(s).equals("-")) {
							String s2 = seek(s);
							if (s2.equals("+") || s2.equals("-")) {
								if (!new ParserTreeRule() {
									@Override
									public boolean parse(ITokenList s) throws SyntaxError {
									String s2 = seek(s);
									if (s2.equals("+")) {
										if (seek(s).equals("+")) if (children.get("op") == null) {
											children.put("op", new ArrayList<Object>());
											((List<Object>) children.get("op")).add(next(s));
										}
										else ((List<Object>) children.get("op")).add(next(s));
										else accept("+", s);
										return true;
									}
									if (s2.equals("-")) {
										if (seek(s).equals("-")) if (children.get("op") == null) {
											children.put("op", new ArrayList<Object>());
											((List<Object>) children.get("op")).add(next(s));
										}
										else ((List<Object>) children.get("op")).add(next(s));
										else accept("-", s);
										return true;
									}
									accept(new String[] {"+", "-"}, s);
									return false;
									}
								}.parse(s));
								{
									ParserTreeRule rule = new GeneratedRule_Term();
									if(!rule.parse(s)) ; else if (children.get("b") == null) {
										children.put("b", new ArrayList<Object>());
										((List<Object>) children.get("b")).add(rule);
									}
									else ((List<Object>) children.get("b")).add(rule);
								}
								return true;
							}
							accept(new String[] {"+", "-"}, s);
							return false;
						} return false;
						}
					}.parse(s)) si2 = s.index();
					s.setIndex(si2);
				}
				return true;
			}
			accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "func", "nil", "{"}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_Expression ast_Expression(PTreeNode node) {
		if (node == null) return null;
		Rule_Expression a = new Rule_Expression();
		a.a = ast_Term((PTreeNode) node.children.get("a"));
		if (node.children.get("op") != null)
		a.op = ((List<String>) node.children.get("op"));
		a.b = new ArrayList<>();
		if (node.children.get("b") != null)
		for (Object o: (List<?>) node.children.get("b")) {
			a.b.add(ast_Term((PTreeNode) o));
		}
		return a;
	}

	class GeneratedRule_StmList extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (s2.equals("return") || s2.equals("(") || s2.equals("print") || s2.equals("while") || s2.equals("-") || s2.equals("break") || Parser.isValidIdentifier(s2) || s2.equals("if") || s2.equals("do") || s2.equals("func") || s2.equals("{") || s2.equals("nil") || s2.matches("[0-9]+")) {
				if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
					int si2 = s.index();
					while (new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						if (seek(s).equals("return") || seek(s).equals("(") || seek(s).equals("print") || seek(s).equals("while") || seek(s).equals("-") || seek(s).equals("break") || Parser.isValidIdentifier(seek(s)) || seek(s).equals("if") || seek(s).equals("do") || seek(s).equals("func") || seek(s).equals("{") || seek(s).matches("[0-9]+") || seek(s).equals("nil")) {
							String s2 = seek(s);
							if (s2.equals("break") || Parser.isValidIdentifier(s2) || s2.equals("if") || s2.equals("return") || s2.equals("do") || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("print") || s2.equals("while") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
								{
									ParserTreeRule rule = new GeneratedRule_Statement();
									if(!rule.parse(s)) ; else if (children.get("block") == null) {
										children.put("block", new ArrayList<Object>());
										((List<Object>) children.get("block")).add(rule);
									}
									else ((List<Object>) children.get("block")).add(rule);
								}
								return true;
							}
							accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "break", "do", "func", "if", "nil", "print", "return", "while", "{"}, s);
							return false;
						} return false;
						}
					}.parse(s)) si2 = s.index();
					s.setIndex(si2);
				}
				return true;
			}
			accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "break", "do", "func", "if", "nil", "print", "return", "while", "{"}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_StmList ast_StmList(PTreeNode node) {
		if (node == null) return null;
		Rule_StmList a = new Rule_StmList();
		a.block = new ArrayList<>();
		if (node.children.get("block") != null)
		for (Object o: (List<?>) node.children.get("block")) {
			a.block.add(ast_Statement((PTreeNode) o));
		}
		return a;
	}

	class GeneratedRule_FunctionCall extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (Parser.isValidIdentifier(s2) || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
				{
					ParserTreeRule rule = new GeneratedRule_Prim();
					if(!rule.parse(s)) ; else children.put("a", rule);
				}
				if (seek(s).equals("(")) {
					int si2 = s.index();
					while (new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						if (seek(s).equals("(")) {
							String s2 = seek(s);
							if (s2.equals("(")) {
								{
									ParserTreeRule rule = new GeneratedRule_Arguments();
									if(!rule.parse(s)) ; else if (children.get("b") == null) {
										children.put("b", new ArrayList<Object>());
										((List<Object>) children.get("b")).add(rule);
									}
									else ((List<Object>) children.get("b")).add(rule);
								}
								return true;
							}
							accept(new String[] {"("}, s);
							return false;
						} return false;
						}
					}.parse(s)) si2 = s.index();
					s.setIndex(si2);
				}
				return true;
			}
			accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "func", "nil", "{"}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_FunctionCall ast_FunctionCall(PTreeNode node) {
		if (node == null) return null;
		Rule_FunctionCall a = new Rule_FunctionCall();
		a.a = ast_Prim((PTreeNode) node.children.get("a"));
		a.b = new ArrayList<>();
		if (node.children.get("b") != null)
		for (Object o: (List<?>) node.children.get("b")) {
			a.b.add(ast_Arguments((PTreeNode) o));
		}
		return a;
	}

	class GeneratedRule_Term extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (Parser.isValidIdentifier(s2) || s2.equals("func") || s2.equals("(") || s2.equals("{") || s2.equals("nil") || s2.equals("-") || s2.matches("[0-9]+")) {
				{
					ParserTreeRule rule = new GeneratedRule_MemberAccess();
					if(!rule.parse(s)) ; else children.put("a", rule);
				}
				if (seek(s).equals("*") || seek(s).equals("/")) {
					int si2 = s.index();
					while (new ParserTreeRule() {
						@Override
						public boolean parse(ITokenList s) throws SyntaxError {
						if (seek(s).equals("*") || seek(s).equals("/")) {
							String s2 = seek(s);
							if (s2.equals("*") || s2.equals("/")) {
								if (!new ParserTreeRule() {
									@Override
									public boolean parse(ITokenList s) throws SyntaxError {
									String s2 = seek(s);
									if (s2.equals("*")) {
										if (seek(s).equals("*")) if (children.get("op") == null) {
											children.put("op", new ArrayList<Object>());
											((List<Object>) children.get("op")).add(next(s));
										}
										else ((List<Object>) children.get("op")).add(next(s));
										else accept("*", s);
										return true;
									}
									if (s2.equals("/")) {
										if (seek(s).equals("/")) if (children.get("op") == null) {
											children.put("op", new ArrayList<Object>());
											((List<Object>) children.get("op")).add(next(s));
										}
										else ((List<Object>) children.get("op")).add(next(s));
										else accept("/", s);
										return true;
									}
									accept(new String[] {"*", "/"}, s);
									return false;
									}
								}.parse(s));
								{
									ParserTreeRule rule = new GeneratedRule_MemberAccess();
									if(!rule.parse(s)) ; else if (children.get("b") == null) {
										children.put("b", new ArrayList<Object>());
										((List<Object>) children.get("b")).add(rule);
									}
									else ((List<Object>) children.get("b")).add(rule);
								}
								return true;
							}
							accept(new String[] {"*", "/"}, s);
							return false;
						} return false;
						}
					}.parse(s)) si2 = s.index();
					s.setIndex(si2);
				}
				return true;
			}
			accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "func", "nil", "{"}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	@SuppressWarnings("all")
	private Rule_Term ast_Term(PTreeNode node) {
		if (node == null) return null;
		Rule_Term a = new Rule_Term();
		a.a = ast_MemberAccess((PTreeNode) node.children.get("a"));
		if (node.children.get("op") != null)
		a.op = ((List<String>) node.children.get("op"));
		a.b = new ArrayList<>();
		if (node.children.get("b") != null)
		for (Object o: (List<?>) node.children.get("b")) {
			a.b.add(ast_MemberAccess((PTreeNode) o));
		}
		return a;
	}

	class GeneratedRule_0 extends PTreeNode implements ParserTreeRule {
		@SuppressWarnings("all")
		@Override
		public boolean parse(ITokenList s) throws SyntaxError {
			String s2 = seek(s);
			if (s2.equals("return") || s2.equals("(") || s2.equals("print") || s2.equals("while") || s2.equals("-") || s2.equals("break") || Parser.isValidIdentifier(s2) || s2.equals("if") || s2.equals("do") || s2.equals("func") || s2.equals("{") || s2.matches("[0-9]+") || s2.equals("nil")) {
				{
					ParserTreeRule rule = new GeneratedRule_Start();
					if(!rule.parse(s)) ; else children.put("Start", rule);
				}
				return true;
			}
			accept(new String[] {"(", "-", "<ID>", "<NUMBER>", "break", "do", "func", "if", "nil", "print", "return", "while", "{"}, s);
			return false;

		}
		@Override
		public String toString() {
			return children.toString();
		}
	}

	public class Rule_Member {
		public String member;
		public Rule_Expression key;
		public String op;
	}

	public class Rule_Arguments {
		public List<Rule_Expression> args;
	}

	public class Rule_Start {
		public List<Rule_Statement> stm;
	}

	public class Rule_MemberAccess {
		public Rule_Expression value;
		public Rule_FunctionCall a;
		public String op;
		public List<Rule_Member> b;
	}

	public class Rule_Prim {
		public int number;
		public Rule_LValue lval;
		public Rule_Statement stm;
		public List<Rule_Expression> values;
		public Rule_Expression expr;
		public List<String> params;
		public String op;
	}

	public class Rule_LValue {
		public String variable;
	}

	public class Rule_Statement {
		public List<Rule_Expression> elsecond;
		public Rule_Expression cond;
		public List<Rule_Statement> block;
		public String cmd;
		public Rule_Expression expr;
		public List<Rule_Statement> elseBlock;
		public List<Rule_StmList> elseif;
		public Rule_Expression rv;
	}

	public class Rule_Expression {
		public List<Rule_Term> b;
		public Rule_Term a;
		public List<String> op;
	}

	public class Rule_StmList {
		public List<Rule_Statement> block;
	}

	public class Rule_FunctionCall {
		public List<Rule_Arguments> b;
		public Rule_Prim a;
	}

	public class Rule_Term {
		public List<Rule_MemberAccess> b;
		public List<String> op;
		public Rule_MemberAccess a;
	}


	// TODO check reserved words
	public static boolean isValidIdentifier(String s) {

		if (s.equals("while")) return false;
		if (s.equals("break")) return false;
		if (s.equals("if")) return false;
		if (s.equals("]")) return false;
		if (s.equals("func")) return false;
		if (s.equals("do")) return false;
		if (s.equals("[")) return false;
		if (s.equals("end")) return false;
		if (s.equals("else")) return false;
		if (s.equals("->")) return false;
		if (s.equals("*")) return false;
		if (s.equals("return")) return false;
		if (s.equals("+")) return false;
		if (s.equals("(")) return false;
		if (s.equals(")")) return false;
		if (s.equals(".")) return false;
		if (s.equals("/")) return false;
		if (s.equals(",")) return false;
		if (s.equals("print")) return false;
		if (s.equals("-")) return false;
		if (s.equals("then")) return false;
		if (s.equals(";")) return false;
		if (s.equals(":")) return false;
		if (s.equals("elseif")) return false;
		if (s.equals("}")) return false;
		if (s.equals("{")) return false;
		if (s.equals("=")) return false;
		if (s.equals("nil")) return false;
		return s.toLowerCase().matches("[a-z0-9_]+");
	}

	/** Parse TokenList and return AST object */
	public Rule_Start parseTokenList(ITokenList s) throws SyntaxError {

		GeneratedRule_0 t =  new GeneratedRule_0();
		t.parse(s);
		return ast_Start((GeneratedRule_Start) t.children.get("Start"));
	}

	public boolean parse(ITokenList s) throws SyntaxError {

		return new GeneratedRule_0().parse(s);
	}

	{
	}
	class BreakException extends RuntimeException {
	}
	class ReturnException extends RuntimeException {
		public ToyValue returnValue ;
		public ReturnException (ToyValue v ){
			returnValue =v ;
		}
	}
	void run (Rule_Start s ){
		for (Rule_Statement s1 :s.stm)exec (s1 );
	}
	void exec (Rule_Statement t ){
		if ("print".equals(t.cmd))System.out.println(eval_Expression (t.expr));
		else if ("do".equals(t.cmd)){
			Scope tmp =scope ;
			scope =new Scope (scope );
			for (Rule_Statement s :t.block){
				exec (s );
			}
			scope =tmp ;
		}
		else if ("while".equals(t.cmd)){
			Scope tmp =scope ;
			scope =new Scope (scope );
			while (((Integer )eval_Expression (t.cond).value)!=0 )for (Rule_Statement s :t.block){
				try {
					exec (s );
				}
				catch (BreakException ex ){
					break ;
				}
			}
			scope =tmp ;
		}
		else if ("if".equals(t.cmd)){
			Scope tmp =scope ;
			scope =new Scope (scope );
			if (((Integer )eval_Expression (t.cond).value)!=0 )for (Rule_Statement s :t.block){
				exec (s );
			}
			else {
				boolean flag =true ;
				for (int i =0 ;
				i <t.elsecond.size();
				i ++){
					Rule_Expression cond =t.elsecond.get(i );
					Rule_StmList block =t.elseif.get(i );
					if (((Integer )eval_Expression (cond ).value)!=0 ){
						for (Rule_Statement s :block.block){
							exec (s );
						}
						flag =false ;
						break ;
					}
				}
				if (flag ){
					for (Rule_Statement s :t.elseBlock){
						exec (s );
					}
				}
			}
			scope =tmp ;
		}
		else if ("break".equals(t.cmd))throw new BreakException ();
		else if ("return".equals(t.cmd))throw new ReturnException (eval_Expression (t.rv));
		else eval_Expression (t.expr);
	}
	ToyValue eval_Expression (Rule_Expression t ){
		ToyValue a =eval_Term (t.a);
		if (t.op!=null )for (int i =0 ;
		i <t.op.size();
		i ++){
			if (t.op.get(i ).equals("+")){
				a =new ToyValue (((Integer )a.value)+(Integer )eval_Term (t.b.get(i )).value);
			}
			else if (t.op.get(i ).equals("-")){
				a =new ToyValue (((Integer )a.value)-(Integer )eval_Term (t.b.get(i )).value);
			}
		}
		return a ;
	}
	ToyValue eval_Term (Rule_Term t ){
		ToyValue a =eval_MemberAccess (t.a);
		if (t.op!=null )for (int i =0 ;
		i <t.op.size();
		i ++){
			if (t.op.get(i ).equals("*")){
				a =new ToyValue (((Integer )a.value)*(Integer )eval_MemberAccess (t.b.get(i )).value);
			}
			else if (t.op.get(i ).equals("/")){
				a =new ToyValue (((Integer )a.value)/(Integer )eval_MemberAccess (t.b.get(i )).value);
			}
		}
		return a ;
	}
	ToyValue eval_MemberAccess (Rule_MemberAccess t ){
		ToyValue a =eval_FunctionCall (t.a);
		if (t.b!=null )for (int i =0 ;
		i <t.b.size();
		i ++){
			if (a.type==Datatype.TABLE){
				if (((Map <String ,ToyValue >)a.value).get(getKey (t.b.get(i )))==null &&i ==t.b.size()-1&&t.value!=null ){
					((Map <String ,ToyValue >)a.value).put(getKey (t.b.get(i )),new ToyValue (0 ));
				}
				a =((Map <String ,ToyValue >)a.value).get(getKey (t.b.get(i )));
			}
			else {
				if (".".equals(t.b.get(i ).op)){
					if (t.b.get(i ).member.equals("length"))a =new ToyValue (((List <ToyValue >)a.value).size());
				}
				else a =((List <ToyValue >)a.value).get(getIndex (t.b.get(i )));
			}
		}
		if (t.value!=null &&"=".equals(t.op)){
			ToyValue v =eval_Expression (t.value);
			a.type=v.type;
			a.value=v.value;
		}
		else if (":".equals(t.op)){
			((List <ToyValue >)a.value).add(eval_Expression (t.value));
		}
		return a ;
	}
	int getIndex (Rule_Member t ){
		if (t.op.equals("["))return (Integer )eval_Expression (t.key).value;
		return 0 ;
	}
	String getKey (Rule_Member t ){
		if (t.op.equals("."))return t.member;
		else return eval_Expression (t.key).value.toString();
	}
	ToyValue eval_FunctionCall (Rule_FunctionCall t ){
		ToyValue a =eval_Prim (t.a);
		if (t.b!=null )for (int i =0 ;
		i <t.b.size();
		i ++){
			a =call_Function (a ,t.b.get(i ));
		}
		return a ;
	}
	ToyValue call_Function (ToyValue f1 ,Rule_Arguments args ){
		Function f =(Function )f1.value;
		Scope tmp =scope ;
		Scope newscope =new Scope (f.localScope);
		for (int i =0 ;
		i <f.params.size();
		i ++){
			newscope.scope.put(f.params.get(i ),eval_Expression (args.args.get(i )));
		}
		scope =newscope ;
		ToyValue t =new ToyValue (0 );
		if (f.body.cmd==null )t =eval_Expression (f.body.expr);
		else try {
			exec (f.body);
		}
		catch (ReturnException re ){
			t =re.returnValue;
		}
		scope =tmp ;
		return t ;
	}
	ToyValue eval_Prim (Rule_Prim t ){
		if (t.lval!=null ){
			if (t.expr!=null ){
				scope.setVar(t.lval.variable,eval_Expression (t.expr));
			}
			return scope.getVar(t.lval.variable);
		}
		else if ("nil".equals(t.op)){
			if (t.expr!=null ){
				eval_Expression (t.expr);
			}
			return new ToyValue (0 );
		}
		else if ("-".equals(t.op)){
			return new ToyValue (-((Integer )eval_Expression (t.expr).value));
		}
		else if ("func".equals(t.op)){
			return new ToyValue (new Function (t.params!=null ?t.params:new ArrayList <String >(),t.stm,scope ));
		}
		else if ("table".equals(t.op)){
			return new ToyValue (new HashMap <String ,ToyValue >());
		}
		else if ("{".equals(t.op)){
			List <ToyValue >a =new ArrayList <>();
			for (Rule_Expression e :t.values)a.add(eval_Expression (e ));
			return new ToyValue (a );
		}
		else if (t.expr!=null ){
			return eval_Expression (t.expr);
		}
		else {
			return new ToyValue (t.number);
		}
	}
	final Scope globalScope =new Scope ();
	Scope scope =globalScope ;
	class Scope {
		HashMap <String ,ToyValue >scope =new HashMap <>();
		Scope superScope =null ;
		public Scope (){
		}
		public Scope (Scope superS ){
			superScope =superS ;
		}
		public ToyValue getVar (String name ){
			if (scope.containsKey(name ))return scope.get(name );
			else if (superScope !=null )return superScope.getVar(name );
			else return null ;
		}
		public void setVar (String name ,ToyValue val ){
			if (scope.containsKey(name )||(superScope !=null &&superScope.getVar(name )==null ))scope.put(name ,val );
			else if (superScope !=null )superScope.setVar(name ,val );
			else scope.put(name ,val );
		}
	}
	class Function {
		List <String >params ;
		Rule_Statement body ;
		Scope localScope ;
		public Function (List <String >params ,Rule_Statement body ,Scope s ){
			this.params=params ;
			this.body=body ;
			this.localScope=s ;
		}
	}
	enum Datatype {
		FUNCTION ,INTEGER ,TABLE ,LIST }
	class ToyValue {
		Datatype type ;
		Object value ;
		public ToyValue (Map <String ,ToyValue >m ){
			type =Datatype.TABLE;
			value =m ;
		}
		public ToyValue (List <ToyValue >l ){
			type =Datatype.LIST;
			value =l ;
		}
		public ToyValue (int i ){
			type =Datatype.INTEGER;
			value =i ;
		}
		public ToyValue (Function f ){
			type =Datatype.FUNCTION;
			value =f ;
		}
		public String toString (){
			return value.toString();
		}
		public boolean equals (Object o ){
			if (o instanceof ToyValue ){
				return type ==((ToyValue )o ).type&&value .equals(((ToyValue )o ).value);
			}
			else return super.equals(o );
		}
	}


	// TODO implement your own main-method
	public static void main(String[] args) throws StringIndexOutOfBoundsException, IOException {

		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		String text = "", tmp = "";
		while (!(tmp = r.readLine()).equals(";;;")) text += tmp + "\n";
		TokenScanner s = new TokenScanner(); // TODO you may use your own lexer here
			s.setSpecialTokens(new char[]{';', '<', '>', '(', ')', ',', ':', '+', '-', '*', '/', '%', '=', '&', '|', '{', '}', '.', '!', '[', ']', '$'});
			s.setBSpecialTokens(new String[]{"->", "=>", "==", "!=", "&&", "||", "<=", ">=", "++", "--", "::"});
			s.setComments(true);
			s.init(text);
		r.close();
		try {
			CodeGenerator.generate_Start(new Parser().parseTokenList(s)); // Generate code using an automatically generated code generator
		} catch (UnexpectedTokenSyntaxError e) {
			
			if (e.getExceptedArray() == null) {
				System.err.println("[Line "+e.getLine()+"] Syntax error on token '" + e.getToken() + "', expected '" + e.getExcepted() + "'");
				//e.printStackTrace();
				} else {
				System.err.println("[Line "+e.getLine()+"] Syntax error on token '" + e.getToken() + "', expected one of:");
				for (String token : e.getExceptedArray()) {
					System.err.println("[Line "+e.getLine()+"] 		'" + token + "'");
				}
			}
			
			System.err.println("[Line "+e.getLine()+"] Line: '" + s.getLine(e.getLine()-1).trim() + "'");
		} catch (SyntaxError e) {
		
			System.err.println("[Line "+e.getLine()+"] " + e.getMessage());
			System.err.println("[Line "+e.getLine()+"] 	" + s.getLine(e.getLine()-1).trim());
		}
	}

}

