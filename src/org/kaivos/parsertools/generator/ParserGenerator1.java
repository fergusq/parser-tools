package org.kaivos.parsertools.generator;



import java.io.BufferedReader;
import java.io.File;
//import java.io.File;
//import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;

import org.kaivos.parsertools.CodeGenerationException;
import org.kaivos.parsertools.ParserGenerationTools;
import org.kaivos.parsertools.ParserGenerationTools.ASTProcessorFunction;
import org.kaivos.parsertools.ParserGenerationTools.ParserRule;
//import org.kaivos.parsertools.ParserGenerationTools.Rule;
import org.kaivos.parsertools.ParserGenerationTools.SemanticSelector;
import org.kaivos.parsertools.ParserGenerationTools.SpecialToken;
import org.kaivos.parsertools.ParserTree;
import org.kaivos.sc.TokenScanner;
import org.kaivos.stg.error.SyntaxError;
import org.kaivos.stg.error.UnexpectedTokenSyntaxError;

public class ParserGenerator1 {

	public static final String NAME = "ParserGenerator1";
	public static final String VERSION = "a0.1";
	public static final String[] COMMENT = {
		"(C) 2013 Iikka Hauhio - ALL RIGHTS RESERVED",
		"THIS GENERATOR IS ONLY A PROTOTYPE"
	};
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		ParserGenerationTools g = new ParserGenerationTools();
		String filename = null, out_package = null;
		String out_folder = ".";
		String start = "Start";
		g.LL1 = true;
		int i = 0;
		
		for (i = 0; i < args.length; i++) {
			if (args[i].toLowerCase().equals("-ll1")) {
				g.LL1 = true;
			}
			else if (args[i].toLowerCase().equals("-backtracking")) {
				g.LL1 = false;
			}
			else if (args[i].toLowerCase().equals("-start")) {
				start = args[++i];
			} else if (args[i].toLowerCase().equals("-out")) {
				out_folder = args[++i];
				if (out_folder.endsWith("/")) out_folder = out_folder.substring(0, out_folder.length()-1);
			} else if (args[i].toLowerCase().equals("-h") || args[i].toLowerCase().equals("-help")) {
				System.out.println("Usage: pg1 [OPTIONS] grammar_file output_package\n" +
						"\t-start rule\tUse rule as start rule\n" +
						"\t-out folder\tPut output files to specific folder\n" +
						"\t-ll1\t\tGenerate LL(1) parser instead of backtracking LL(1) parser\n" +
						"\t-backtracking\tGenerate backtracking LL(1) parser instead of LL(1) parser\n" +
						"\t-help\t\tDisplay this help text");
				return;
			} else {
				if (i < args.length-2) { // Jos ei ole toiseksi viimeinen argumentti eli kielioppitiedosto tai viimeinen eli paketti
					System.err.println("Unknown option: " + args[i]);
					System.exit(0);
				}
			}
		}

		filename = args[i-2];
		out_package = args[i-1];
		
		ParserRule rule1 = g.new Rule("__Start__", 
				new Object[][] {
						{g.new RuleProperty("Start", g.new RuleReferenceString(start))}
				}
			);
		
		readGrammar(g, filename);
		
		String parserCode = "";
		
		parserCode = addLn(parserCode, "// AUTO GENERATED PARSER CLASS");
		parserCode = addLn(parserCode, "// GENERATED BY " + NAME);
		parserCode = addLn(parserCode, "//");
		parserCode = addLn(parserCode, "// GENERATOR VERSION: " + VERSION);
		for (String s : COMMENT)
			parserCode = addLn(parserCode, "// " + s);
		parserCode = addLn(parserCode, "//");
		parserCode = addLn(parserCode, "// GRAMMAR FILE: " + filename);
		parserCode = addLn(parserCode, "");
		
		parserCode = addLn(parserCode, "package " + out_package + ";"); // tulosta kielioppitiedoston package-osio
		
		// Parserin käyttämät luokat
		parserCode = addLn(parserCode, "import org.kaivos.parsertools.ParserTree;\n" +
				"import org.kaivos.sc.ITokenList;\n" +
				"import org.kaivos.stg.error.SyntaxError;\n" +
				"import org.kaivos.stg.error.UnexpectedTokenSyntaxError;\n" +
				"import java.util.Map;\n" +
				"import java.util.HashMap;\n" +
				"import java.util.List;\n" +
				"import java.util.ArrayList;\n" +
				"import java.io.BufferedReader;\n" +
				"import java.io.InputStreamReader;\n" +
				"import org.kaivos.sc.TokenScanner;\n" +
				"import java.io.IOException;");
		
		parserCode = addLn(parserCode, imports); // tulosta kielioppitiedoston import-osio
		
		// ParserTreeRule -rajapinta --- välttämätön parserille
		parserCode = addLn(parserCode, "interface ParserTreeRule {\n" +
				"	public boolean parse(ITokenList l) throws SyntaxError;\n" +
				"}\n");
		
		// PTreeNode --- välttämätön parserille
		parserCode = addLn(parserCode, "class PTreeNode {\n" +
				"	Map<String, Object> children = new HashMap<>();\n" +
				"}\n");
		
		parserCode = addLn(parserCode, "public class Parser extends ParserTree implements ParserTreeRule {\n");
		
		// Tulosta itse parseri
		try {
			parserCode = addLn(parserCode, g.parser(rule1));
		} catch (CodeGenerationException e) {
			System.err.println("(" + g.currentRule + ") " + e.getMessage());
		}
	
		// isValidIdentifier --- tarkistaa onko merkkijono sallittu nimi
		parserCode = addLn(parserCode, "	// TODO check reserved words");
		parserCode = addLn(parserCode, "	public static boolean isValidIdentifier(String s) {\n");
		
		// mahdolliset avainsanat
		for (String s: g.possibleKeywords) {
			parserCode = addLn(parserCode, "		if (s.equals(\"" + escape(s) + "\")) return false;");
		}
		
		// on avainsana vain jos koostuu merkeistä a-z, 0-9 ja _
		parserCode = addLn(parserCode, 
				"		return s.toLowerCase().matches(\"[a-z0-9_]+\");\n" +
				"	}\n");
		
		// Parsii "s":n ja palauttaa AST-olion 
		parserCode = addLn(parserCode, "	/** Parse TokenList and return AST object */");
		parserCode = addLn(parserCode, "	public Rule_"+start+" parseTokenList(ITokenList s) throws SyntaxError {\n");
		parserCode = addLn(parserCode, "		GeneratedRule_"+(g.ruleCounter-1)+" t =  new GeneratedRule_"+(g.ruleCounter-1)+"();");
		parserCode = addLn(parserCode, "		t.parse(s);");
		parserCode = addLn(parserCode, "		return ast_" + start + "((GeneratedRule_"+start+") t.children.get(\"Start\"));");
		parserCode = addLn(parserCode, "	}\n");
		
		// toteuta ParserTreeRule -rajapinta --- palauttaa true jos "s" ei sisällä syntax erroreita
		parserCode = addLn(parserCode, "	public boolean parse(ITokenList s) throws SyntaxError {\n");
		parserCode = addLn(parserCode, "		return new GeneratedRule_"+(g.ruleCounter-1)+"().parse(s);");
		parserCode = addLn(parserCode, "	}\n");
		
		// tulosta kielioppitiedoston members-osio
		parserCode = addLn(parserCode, members);
		
		// Tulosta esimerkki --- Ei osa parseria
		parserCode = addLn(parserCode, "	// TODO implement your own main-method");
		parserCode = addLn(parserCode, "	public static void main(String[] args) throws StringIndexOutOfBoundsException, IOException {\n");
		parserCode = addLn(parserCode, "		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));");
		parserCode = addLn(parserCode, "		String text = \"\", tmp = \"\";");
		parserCode = addLn(parserCode, "		while (!(tmp = r.readLine()).equals(\";;;\")) text += tmp + \"\\n\";");
		parserCode = addLn(parserCode, "		TokenScanner s = new TokenScanner(); // TODO you may use your own lexer here");
		parserCode = addLn(parserCode, "			s.setSpecialTokens(new char[]{';', '<', '>', '(', ')', ',', ':', " +
				"'+', '-', '*', '/', '%', '=', '&', '|', '{', '}', '.', '!', '[', ']', '$'});");
		parserCode = addLn(parserCode, "			s.setBSpecialTokens(new String[]{\"->\", \"=>\", \"==\", \"!=\", \"&&\", \"||\", \"<=\", \">=\", \"++\", \"--\", \"::\"});");
		parserCode = addLn(parserCode, "			s.setComments(true);");
		parserCode = addLn(parserCode, "			s.init(text);");
		parserCode = addLn(parserCode, "		r.close();");
		parserCode = addLn(parserCode, "		try {");
		parserCode = addLn(parserCode, "			CodeGenerator.generate_"+start+"(new Parser().parseTokenList(s)); // Generate code using an automatically generated code generator");
		parserCode = addLn(parserCode, "		} catch (UnexpectedTokenSyntaxError e) {");
		parserCode = addLn(parserCode, "			");
		parserCode = addLn(parserCode, "			if (e.getExceptedArray() == null) {");
		parserCode = addLn(parserCode, "				System.err.println" +
				"(\"[Line \"+e.getLine()+\"] Syntax error on token '\" + e.getToken() + \"', expected '\" + e.getExcepted() + \"'\");");
		parserCode = addLn(parserCode, "				//e.printStackTrace();");
		parserCode = addLn(parserCode, "				} else {");
		parserCode = addLn(parserCode, "				System.err.println(\"[Line \"+e.getLine()+\"] Syntax error on token '\" + e.getToken() + \"', expected one of:\");");
		parserCode = addLn(parserCode, "				for (String token : e.getExceptedArray()) {");
		parserCode = addLn(parserCode, "					System.err.println(\"[Line \"+e.getLine()+\"] \t\t'\" + token + \"'\");");
		parserCode = addLn(parserCode, "				}");
		parserCode = addLn(parserCode, "			}");
		parserCode = addLn(parserCode, "			");
		parserCode = addLn(parserCode, "			System.err.println(\"[Line \"+e.getLine()+\"] Line: '\" + s.getLine(e.getLine()-1).trim() + \"'\");");
		parserCode = addLn(parserCode, "		} catch (SyntaxError e) {");
		parserCode = addLn(parserCode, "		");
		parserCode = addLn(parserCode, "			System.err.println(\"[Line \"+e.getLine()+\"] \" + e.getMessage());");
		parserCode = addLn(parserCode, "			System.err.println(\"[Line \"+e.getLine()+\"] \t\" + s.getLine(e.getLine()-1).trim());");
		parserCode = addLn(parserCode, "		}");
		parserCode = addLn(parserCode, "	}\n");
		
		// Sulje luokan {-sulku
		parserCode = addLn(parserCode, "}");
		
		try {
			PrintWriter w = new PrintWriter(new File(out_folder + "/" + out_package.replaceAll("\\.", "/") + "/Parser.java"));
			w.println(parserCode);
			w.close();
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		
		String codeGenCode = "";
		
		codeGenCode = addLn(codeGenCode, "// AUTO GENERATED SAMPLE CODE GENERATOR CLASS");
		codeGenCode = addLn(codeGenCode, "// GENERATED BY " + NAME);
		codeGenCode = addLn(codeGenCode, "//");
		codeGenCode = addLn(codeGenCode, "// GENERATOR VERSION: " + VERSION);
		for (String s : COMMENT)
			codeGenCode = addLn(codeGenCode, "// " + s);
		codeGenCode = addLn(codeGenCode, "//");
		codeGenCode = addLn(codeGenCode, "// GRAMMAR FILE: " + filename);
		codeGenCode = addLn(codeGenCode, "");
		
		codeGenCode = addLn(codeGenCode, "package " + out_package + ";");
		
		codeGenCode = addLn(codeGenCode, "// TODO Implement your own code generator");
		codeGenCode = addLn(codeGenCode, "public class CodeGenerator {");
		codeGenCode = addLn(codeGenCode, g.codeGenClass);
		codeGenCode = addLn(codeGenCode, "}");
		
		try {
			PrintWriter w = new PrintWriter(new File(out_folder + "/" + out_package.replaceAll("\\.", "/") + "/CodeGenerator.java"));
			w.println(codeGenCode);
			w.close();
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		
	}

	private static String addLn(String s, String s2) {
		return s + s2 + "\n";
	}
	
	/**
	 * Muuntaa "-merkit muotoon \"
	 */
	private static String escape(String s) {
		String a = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == '\"') a += "\\\"";
			else a += s.charAt(i);
		}
		return a;
	}

	public static String package_ = new String();
	public static String imports = new String();
	public static String members = new String();
	
	private static void readGrammar(ParserGenerationTools g, String file) {
		
		BufferedReader in = null;
		/*try {
			in = new BufferedReader(new FileReader(new File(file)));
		} catch (Exception e1) {
			e1.printStackTrace();
			return;
		}*/
		
		try {
			Process p = Runtime.getRuntime().exec(new String[] {"cpp", file});
			
			p.waitFor();
			
			// tulosta virheet
			while (p.getErrorStream().available() != 0) System.err.write(p.getErrorStream().read());
			
			in = new BufferedReader(new InputStreamReader(p.getInputStream()));
		} catch (Exception ex) {
			ex.printStackTrace();
			return;
		}
		
		String textIn = "";
		try {
			while (in.ready()) textIn += in.readLine() + "\n";
		} catch (IOException e1) {
			e1.printStackTrace();
			return;
		}
		
		try {
			in.close();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		
		TokenScanner s = new TokenScanner();
		s.setSpecialTokens(new char[]{';', '(', ')', ',', ':', '+', '=', '|', '{', '}', '[', ']', '<', '>', '$', '@', '\\'});
		s.setBSpecialTokens(new String[]{});
		s.setComments(true);
		s.setPrep(true);
		s.init(textIn);
		GrammarParser parser = new GrammarParser();
		try {
			parser.parseRules(g, s);
		} catch (UnexpectedTokenSyntaxError e) {
			
			if (e.getExceptedArray() == null) {
				System.err.println("[Line "+e.getLine()+"] Syntax error on token '" + e.getToken() + "', expected '" + e.getExcepted() + "'");
				//e.printStackTrace();
			} else {
				System.err.println("[Line "+e.getLine()+"] Syntax error on token '" + e.getToken() + "', expected one of:");
				for (String token : e.getExceptedArray()) {
					System.err.println("[Line "+e.getLine()+"] \t\t'" + token + "'");
				}
			}
			
			System.err.println("[Line "+e.getLine()+"] Line: '" + s.getLine(e.getLine()-1).trim() + "'");
			
			System.exit(1);
		} catch (SyntaxError e) {
			
			System.err.println("[Line "+e.getLine()+"] " + e.getMessage());
			System.err.println("[Line "+e.getLine()+"] \t" + s.getLine(e.getLine()-1).trim());
			
			System.exit(1);
		}
		
	}
	
	private static class GrammarParser extends ParserTree {
		public void parseRules(ParserGenerationTools g, TokenScanner s) throws SyntaxError {
			while (!seek(s).equals("<EOF>")) {
				if (seek(s).equals("@")) {
					accept("@", s);
					String position = accept(new String[] {"imports", "members", "package"}, s);
					String code = "\t";
					accept("{", s);
					{ // Parsi Java-koodi
						int d = 1;
						while (d != 0) {
							String tok = next(s);
							if (tok.equals("{")) d++; // laske sulut ja lopeta kun viimeinen sulku löytyy
							if (tok.equals("}")) d--;
							if (tok.equals("\\")) { // \end lopettaa --- \} lisää ylimääräisen sulun
								if (seek(s).equals("end")) {
									accept("end", s);
									break;
								}
								tok = next(s);
							}
							if (d == 0) break;
							
							if (tok.startsWith("\"")) { // lisää escape-merkit merkkijonoon
								tok = tok.substring(1, tok.length()-1).replace("\"", "\\n");
								tok = tok.replace("\n", "\\n");
								tok = "\"" + tok + "\"";
							}
							
							if (tok.matches("[a-zA-Z0-9_]+"))
								code += tok + " ";
							else if (tok.endsWith("{") || tok.endsWith("}") || tok.endsWith(";")) {
								code += tok + "\n";
								if (seek(s).equals("}")) // sisennys
									for (int i = 0; i < d-1; i++) code += "\t";
								else
									for (int i = 0; i < d; i++) code += "\t";
							}
							else code += tok;
						}
					}
					switch (position) {
					case "imports":
						imports += code + "\n";
						break;
					case "members":
						members += code + "\n";
						break;
					case "package":
						package_ += code + "\n";
						break;

					default:
						break;
					}
					continue;
				}
				else parseRule(g, s);
				
			}
			accept("<EOF>", s);
			
		}

		private void parseRule(ParserGenerationTools g, TokenScanner s) throws SyntaxError {
			String name = (next(s));
			String ast = name;
			if (seek(s).equals("("))
			{
				accept("(", s);
				ast = next(s);
				accept(")", s);
			}
			accept(":", s);
			g.addRule(name, ast, g.new Rule(parseOrExpr(g, s)));
			accept(";", s);
		}

		private Object[][] parseOrExpr(ParserGenerationTools g, TokenScanner s) throws SyntaxError {
			ArrayList<Object[]> list = new ArrayList<>();
			
			list.add(parseTokenList(g, s));
			
			while (seek(s).equals("|")) {
				accept("|", s);
				list.add(parseTokenList(g, s));
			}
			
			return (Object[][]) list.toArray(new Object[list.size()][]);
		}

		private Object[] parseTokenList(ParserGenerationTools g, TokenScanner s) throws SyntaxError {
			ArrayList<Object> list = new ArrayList<>();
			
			list.add(parsePrim(g, s));
			
			while (
					!seek(s).equals("|") &&
					!seek(s).equals(";") &&
					!seek(s).equals("]") &&
					!seek(s).equals(")") &&
					!seek(s).equals("}")) {
				list.add(parsePrim(g, s));
			}
			
			return (Object[]) list.toArray(new Object[list.size()]);
		}

		private Object parsePrim(ParserGenerationTools g, TokenScanner s) throws SyntaxError {
			String t = next(s);
			if (t.startsWith("\"")) return t.substring(1, t.length()-1);
			if (t.equals("(")) {
				Object[][] r = parseOrExpr(g, s);
				accept(")", s);
				return r;
			}
			if (t.equals("[")) { // Vaihtoehtoinen
				Object[][] r = parseOrExpr(g, s);
				accept("]", s);
				return g.new Rule_Optional(r);
			}
			if (t.equals("{")) { // Vaihtoehtoinen, voi toistua useamman kerran
				Object[][] r = parseOrExpr(g, s);
				accept("}", s);
				return g.new Rule_Infinite(r);
			}
			if (t.equals("$")) { // Arvo tallennetaan AST:hen
				String name = next(s);
				boolean l = false;
				accept("=", s);
				if (seek(s).equals("+")) { // lista?
					accept("+", s);
					l = true;
				}
				return g.new RuleProperty(name, l, parsePrim(g, s));
			}
			if (seek(s).equals("=")) { // Arvo tallennetaan AST:hen
				String name = t;
				boolean l = false;
				accept("=", s);
				if (seek(s).equals("+")) { // lista?
					accept("+", s);
					l = true;
				}
				return g.new RuleProperty(name, l, parsePrim(g, s));
			}
			if (t.equals("<")) {
				String f = next(s);
				while (seek(s).equals(".")) {
					accept(".", s);
					f += "." + next(s);
				}
				SemanticSelector ss = g.new SemanticSelector(f);
				accept(">", s);
				return ss;
			}
			if (t.equals("@")) {
				
				accept("process", s);
				
				accept("(", s);
				
				String f = next(s);
				while (seek(s).equals(".")) {
					accept(".", s);
					f += "." + next(s);
				}
				ASTProcessorFunction ss = g.new ASTProcessorFunction(f);
				accept(")", s);
				return ss;
			}
			switch (t) {
			case "ID":
				return SpecialToken.IDENTIFIER;
			case "STRING":
				return SpecialToken.STRING;
			case "NUMBER":
				return SpecialToken.NUMBER;
			default:
				return g.new RuleReferenceString(t);
			}
		}
	}
	

}
